# rrt_star_planner.py – RRT* with differential‑drive steering
# -----------------------------------------------------------------------------
# Drop‑in for your library‑sorting project.  Every tree edge is now generated by
# `move_set()`, so the path is kinematically feasible for your JetRacer‑like
# robot.
# -----------------------------------------------------------------------------
from __future__ import annotations

import math
from random import random, uniform
from math   import hypot
import pygame

# ──────────────────────────────────────────────────────────────────────────────
# Re‑use your existing forward‑simulation helper
# ──────────────────────────────────────────────────────────────────────────────

def move_set(node, u_l, u_r, buffer_set, wheel_radius, wheel_base, t_curve=2.0):
    """Simulate an arc for *t_curve* seconds; return ((x,y,θ), cost) or None."""
    t    = 0.0
    cost = 0.0
    dt   = t_curve / 10.0
    x_new, y_new, theta_new = node
    theta_new = math.radians(theta_new)
    u_l *= 2 * math.pi / 60.0        # RPM → rad s⁻¹
    u_r *= 2 * math.pi / 60.0

    while t < t_curve:
        t += dt
        v     = (wheel_radius * 0.5) * (u_r + u_l)
        x_new += v * math.cos(theta_new) * dt
        y_new += v * math.sin(theta_new) * dt
        theta_new += (wheel_radius / wheel_base) * (u_r - u_l) * dt
        cost += abs(v * dt)

        # obstacle hit? --------------------------------------------------
        if (int(math.ceil(x_new)), int(math.ceil(y_new))) in buffer_set or \
           (int(x_new), int(y_new)) in buffer_set:
            return None

    theta_new = math.degrees(theta_new) % 360.0
    return (x_new, y_new, theta_new), cost

# ──────────────────────────────────────────────────────────────────────────────
# Data structures
# ──────────────────────────────────────────────────────────────────────────────

class Node:
    __slots__ = ("x", "y", "theta", "parent", "cost", "control")
    def __init__(self, x: float, y: float, theta: float = 0.0):
        self.x, self.y, self.theta = x, y, theta
        self.parent: Node | None = None
        self.cost   = 0.0          # g‑value
        self.control: tuple[int,int] | None = None   # (u_l, u_r)

    def dist(self, other: "Node") -> float:
        return hypot(self.x - other.x, self.y - other.y)

# ──────────────────────────────────────────────────────────────────────────────
# RRT* planner core
# ──────────────────────────────────────────────────────────────────────────────

class RRTStar:
    def __init__(self, *,
                 start_xy: tuple[float,float],
                 goal_xy:  tuple[float,float],
                 is_free,
                 sample_area: tuple[float,float,float,float],
                 step_len: float = 7.0,
                 search_radius: float = 20.0,
                 goal_sample_rate: float = 0.05,
                 max_iter: int = 3000,
                 RPM1: int = 5,
                 RPM2: int = 7,
                 wheel_radius: float = 0.05,
                 wheel_base: float = 0.57,
                 t_curve: float = 1.0,
                 buffer_set: set[tuple[int,int]] | None = None):

        if buffer_set is None:
            raise ValueError("buffer_set must be supplied for collision checking")

        self.start = Node(*start_xy)
        self.goal  = Node(*goal_xy)
        self.nodes: list[Node] = [self.start]

        self.is_free = is_free
        self.xmin, self.xmax, self.ymin, self.ymax = sample_area
        self.step_len, self.search_radius = step_len, search_radius
        self.goal_rate, self.max_iter = goal_sample_rate, max_iter
        self.RPM1, self.RPM2 = RPM1, RPM2
        self.wheel_radius, self.wheel_base = wheel_radius, wheel_base
        self.t_curve = t_curve
        self.buffer_set = buffer_set

    # ────────────────────────────────────────────────────────────────────
    def plan(self, display: pygame.Surface | None = None):
        if not self.is_free((self.start.x, self.start.y)) or not self.is_free((self.goal.x, self.goal.y)):
            return False, []

        surf = display
        for _ in range(self.max_iter):
            rnd = self._sample()
            nearest = self._nearest(rnd)
            new = self._steer(nearest, rnd)
            if new is None or not self._collision_free(nearest, new):
                continue

            # choose cheapest parent within radius ----------------------
            near_inds = self._near(new)
            parent = nearest; min_cost = nearest.cost + nearest.dist(new)
            for i in near_inds:
                nd = self.nodes[i]
                if self._collision_free(nd, new):
                    c = nd.cost + nd.dist(new)
                    if c < min_cost:
                        parent, min_cost = nd, c
            new.parent, new.cost = parent, min_cost
            self.nodes.append(new)

            # rewire -----------------------------------------------------
            for i in near_inds:
                nd = self.nodes[i]
                alt = new.cost + new.dist(nd)
                if alt < nd.cost and self._collision_free(new, nd):
                    nd.parent, nd.cost = new, alt

            if surf:
                pygame.draw.line(surf, (61,119,245), (new.x, new.y), (parent.x, parent.y))
                pygame.display.update()

            # goal reached? ---------------------------------------------
            if new.dist(self.goal) <= self.step_len and self._collision_free(new, self.goal):
                self.goal.parent = new
                self.goal.cost  = new.cost + new.dist(self.goal)
                return True, self._extract_path()

        return False, []

    # ─────────── helpers ───────────────────────────────────────────────
    def _sample(self):
        if random() < self.goal_rate:
            return (self.goal.x, self.goal.y)
        return (uniform(self.xmin, self.xmax), uniform(self.ymin, self.ymax))

    def _nearest(self, point):
        return min(self.nodes, key=lambda n: (n.x-point[0])**2 + (n.y-point[1])**2)

    def _steer(self, from_node: Node, to_xy):
        rpm_pairs = [(self.RPM1, self.RPM1), (self.RPM1, self.RPM2),
                     (self.RPM2, self.RPM1), (self.RPM2, self.RPM2)]
        best_pos, best_ctrl, best_d = None, None, float("inf")
        for ul, ur in rpm_pairs:
            res = move_set((from_node.x, from_node.y, from_node.theta), ul, ur,
                           self.buffer_set, self.wheel_radius, self.wheel_base, self.t_curve)
            if res is None:
                continue
            (x, y, th), _ = res
            d = hypot(x-to_xy[0], y-to_xy[1])
            if d < best_d:
                best_pos, best_ctrl, best_d = (x, y, th), (ul, ur), d
        if best_pos is None:
            return None
        node = Node(*best_pos)
        node.control = best_ctrl
        return node

    def _collision_free(self, n1: Node, n2: Node):
        if n2.control is None:  # straight‑line fallback
            steps = max(1, int(n1.dist(n2)))
            for i in range(steps+1):
                u = i/steps
                p = (n1.x + u*(n2.x-n1.x), n1.y + u*(n2.y-n1.y))
                if not self.is_free(p):
                    return False
            return True
        # simulate arc exactly as steer did
        return move_set((n1.x, n1.y, n1.theta), *n2.control, self.buffer_set,
                        self.wheel_radius, self.wheel_base, self.t_curve) is not None

    def _near(self, new: Node):
        r2 = self.search_radius ** 2
        return [i for i,n in enumerate(self.nodes) if (n.x-new.x)**2 + (n.y-new.y)**2 <= r2]

    def _extract_path(self):
        path = []
        node: Node | None = self.goal
        while node:
            path.append((node.x, node.y))
            node = node.parent
        return list(reversed(path))

# ──────────────────────────────────────────────────────────────────────────────
# Colour‑based occupancy helper (unchanged)
# ──────────────────────────────────────────────────────────────────────────────

def is_free(p, pxarray, pallet, screen):
    x, y = int(p[0]), int(p[1])
    try:
        col = pxarray[x, y]
    except IndexError:
        return False
    return col not in (screen.map_rgb(pallet["black"]), screen.map_rgb(pallet["green"]))
